   To solve the classic Producer-Consumer problem, I used the SEMAPHORES in kernel space using __INITIALISE_SEMAPHORE(name,val). The idea was that the producer will produce & store the 8 bytes no. in a global array. While doing so, the consumer will not be allowed to enter the space to consume the no. Once the producer is done adding the no., it will signal the consumer which can then go & consume the no. & then signal back to the producer that the array is empty & needs to be filled. While the consumer is taking the no., producer can not enter the space. Thus the cycle is maintained & encourages synchronization.
   Data Structure Used: I made a struct containing an array of long long, as the size of the same is 8 bytes. It also contains an int pointer, which points to the current index.

  First of all, the producer process reads a random 8 bytes(long long) no. from /dev/urandom & then passes it to writer() in kernel space.Writer() checks the empty semaphore, which will be >0(available), so the producer(writer) will enter the area & take the lock semaphore too. In the meanwhile the consumer process, will try to read from reader() in kernel space, but its first semaphore(full) will be 0, so the reader can not go further unless the val becomes >0. So automatically, the reader will not be able to acquire the lock semaphore & this is the reason why producer will first acquire the lock semaphore. Back in writer(producer), it will now write those copied long long no.(8 bytes) into the global struct containing the long long array. The pointer of the same would be adjusted accordingly. Once the writer has written, the writer will signal the reader(consumer) by incrementing the full semaphore. Now the reader process can enter the 1st stage of critical section, but it will still stop there as the lock semaphore is still acquired by the writer(producer). Back in the writer(producer), it will release the lock semaphore too, & the reader(consumer) can now completely enter the critical section & read the value from the queue. It then consumes/destroys the no.(initialises back to 0) in the queue & also changes the pointer. Then it writes the value back to the user space pointer, using __copy_to_user. Back in user space, the consumer process takes this value & prints it. The value is also logged in kernel logs. In the kernel space, then the consumer signals the producer that the queue might be empty using up(&empty). This will increase the empty slot, which was earlier 0. Now the producer can enter again & the cycle continues. 
  Added comments in system calls & programs for step-by-step explanation.