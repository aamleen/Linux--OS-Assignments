In the whole assignment, the basic thinking is that to avoid any deadlock, we take the lock of the 1st thing required, then we check if the successive item can be taken too(i.e. unlocked). If any of the successive required item is not available at the moment, we immediately start releasing the previous locks, so that a thread does not keeps waiting for the other requirement, while sitting with the 1st object. Thus the deadlock is avoided. To release the locks immediately, if not acquired, I have used trylocks, i.e pthread_mutex_trylock (for forks) & sem_trywait (for bowls). trylocks return immediately if the lock is not acquired by the thread, which have the similar functionality of returning back if the item is locked.
  Then I keep on running the eating process in an infinite loop, so that I can stop it manually after required 10 mins.

Now coming to specific sub-problems

Q1: Philosopher requires both forks (left & right)... Deadlock can happen when every philosopher takes(locks) 1 fork on their left or right & keep waiting for the other one to drop the required 2nd fork. Other scenarios of deadlocks can also happen.
    DataStructure used: Mutexes (pthread_mutex_trylock, pthread_mutex_unlock)
    The program starts by creating 5 mutexes(forks) & initialising them. Then 5 threads(philosophers) are created. Then for each thread, an infinite loop is run, in which I call eat(). In this function, the philosopher's no. is passed too. Depending on the philosopher's no., the philosopher tries to acquire the left fork using mutex[i], then if the lock is acquired, philosopher tries to acquire the right fork using mutex[(i+1)%5]. If the philosopher gets this lock too, then he starts eating & takes 2 seconds, & then releases both the forks (locks). If the philosopher does not get the right fork (lock), then he does not wait to get it, but returns & also releases the 1st fork, so that a deadlock does not happen. 
  In the very first place, if the philosopher does not get the 1st fork only, then he keeps on trying to get 1.

Q2: Philosopher requires 1 fork & bowl... Deadlock can not happen, as only a bowl is shared & in that case, it can be easily taken & released depending on availability. Its not like a philosopher will sit with 1 bowl & wait for another thing, so deadlock can not happen. Since each philosopher has their own 1 fixed fork(left fork), so there is no sharing/synchronization required in this. Then sharing happens in the 4 bowls required by 5 philosophers. But here too, any philosopher can pick up a bowl, eat from it & keep it back. Similarly 4 philosophers take 4 bowls at a time & then return them, so that the 5th person can eat too. Thus using Counting Semaphores here with value as 4, representing 4 bowls entering the critical section (bowls) at once.
    The program starts by creating & initialising the semaphore with value 4, representing 4 bowls. Then the 5 philosophers(threads) are created. Then for each thread, an infinite loop is run, in which they call the method takeBowl(). In the given method, a philosopher(thread) tries to enter the critical section(taking bowl), depending on the availability of the bowl(sem_trywait). If no bowl is available(blocked), the philosopher returns & waits for a bit & then again tries to get the bowl. Whenever any bowl is available, the philosopher takes it & starts eating (takes 2 secs). Then keeps the bowl back(sem_post). Thus a synchronization is maintined between the philosophers(threads) & they keep on eating unless we signal them to stop.

Q3: Philosopher requires both forks & 1 bowl out of 4. Deadlock can happen when the philosopher has 1 fork & keeps waiting for other, or philsopher has both forks but keeps waiting for bowl & never drops(releases) the forks. DataStructures used: Semaphores & Mutexes
     The program starts by creating & initialising a semaphore with value as 4(4 bowls) & 5 mutexes(forks). Then 5 philosophers(threads) are created. Each thread then runs in an infinite loop. First a philosopher tries to take the shared bowls. Since no fixed orientation is required, a philosopher can pick any of the available 4 bowls. Thus 4 threads can enter the critical section at once. Then if the philosopher is able to take the bowl, he then goes to take the forks. He tries to first take(lock) the left fork using mutex[i]. If succeeded, he tries to take the right fork using mutex[i+1]. If succeeded here too, the philosopher then starts eating(takes 2 secs) & then keeps both the forks down & returns to takeBowl() & keeps the bowl back. If at any step, philosopher is not able to take a thing, say the 2nd right fork, then he immediately returns & keeps(unlocks) down the 1st left fork, & then keeps back the bowl too. Then tries next time. If the 1st left fork was not available in the first place, immediately the bowl is kept back too. Then tries again from beginning.
   Thus a thread does not keeps sitting with 1 single thing, waiting for next resource to become available which in turn is taken by someone else. Thus avoiding any possibility of deadlock.
  